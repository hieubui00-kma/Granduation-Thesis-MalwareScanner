package com.kma.malwarescanner.core.data.local.source

import android.content.ContentResolver
import android.content.pm.ApplicationInfo
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.GET_META_DATA
import android.content.pm.PackageManager.GET_PERMISSIONS
import android.content.pm.PackageManager.GET_RECEIVERS
import android.content.pm.PackageManager.GET_SERVICES
import androidx.core.net.toUri
import com.kma.apktool.ApkFile
import com.kma.malwarescanner.core.data.local.model.isSystemApplication
import com.kma.malwarescanner.core.data.util.copyTo
import com.kma.malwarescanner.core.data.util.getInstalledApplicationsCompat
import com.kma.malwarescanner.core.data.util.getPackageInfoCompat
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.File
import java.io.FileNotFoundException
import java.util.UUID
import javax.inject.Inject
import javax.inject.Named

class ApplicationLocalDataSource @Inject constructor(
    private val packageManager: PackageManager,

    @Named("cache")
    private val cacheStorage: File,

    private val contentResolver: ContentResolver,

    @Named("io")
    private val ioDispatcher: CoroutineDispatcher
) {

    suspend fun getInstalledApplications(): List<ApplicationInfo> = withContext(context = ioDispatcher) {
        return@withContext packageManager
            .getInstalledApplicationsCompat(flags = GET_META_DATA)
            .filterNot { info -> info.isSystemApplication }
    }

    suspend fun getApplicationName(info: ApplicationInfo): String = withContext(context = ioDispatcher) {
        return@withContext packageManager
            .getApplicationLabel(info)
            .toString()
    }

    suspend fun getInstallTime(packageName: String): Long? = withContext(context = ioDispatcher) {
        val packageInfo = getPackageInfo(packageName = packageName)

        return@withContext packageInfo?.firstInstallTime
    }

    suspend fun getUpdateTime(packageName: String): Long? = withContext(context = ioDispatcher) {
        val packageInfo = getPackageInfo(packageName = packageName)

        return@withContext packageInfo?.lastUpdateTime
    }

    private suspend fun getPackageInfo(packageName: String): PackageInfo? = withContext(context = ioDispatcher) {
        val flags = GET_META_DATA or GET_PERMISSIONS or GET_SERVICES or GET_RECEIVERS

        return@withContext packageManager
            .getPackageInfoCompat(packageName = packageName, flags = flags)
            ?.takeUnless { info -> info.applicationInfo.isSystemApplication }
    }

    suspend fun getSource(uri: String): File? = withContext(context = ioDispatcher) {
        val inputStream = try {
            contentResolver.openInputStream(uri.toUri())
        } catch (exception: FileNotFoundException) {
            Timber.d(t = exception)
            return@withContext null
        }
        val uuid = UUID.randomUUID().toString()
        val file = File(cacheStorage, "$uuid.apk")

        inputStream?.use { stream -> stream.copyTo(file = file, context = ioDispatcher) }
        return@withContext file
    }

    suspend fun getAPIs(path: String): List<String> {
        return ApkFile(path = path).getAPIs(cache = cacheStorage)
    }
}
