package com.kma.malwarescanner.core.data.local.source

import android.content.pm.ApplicationInfo
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import android.content.pm.PackageManager.GET_META_DATA
import android.content.pm.PackageManager.GET_PERMISSIONS
import android.content.pm.PackageManager.GET_RECEIVERS
import android.content.pm.PackageManager.GET_SERVICES
import com.kma.malwarescanner.core.data.local.model.isSystemApplication
import com.kma.malwarescanner.core.data.util.getInstalledApplicationsCompat
import com.kma.malwarescanner.core.data.util.getPackageInfoCompat
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Named

class ApplicationLocalDataSource @Inject constructor(
    private val packageManager: PackageManager,

    @Named("io")
    private val ioDispatcher: CoroutineDispatcher
) {

    suspend fun getInstalledApplications(): List<ApplicationInfo> = withContext(context = ioDispatcher) {
        return@withContext packageManager
            .getInstalledApplicationsCompat(flags = GET_META_DATA)
            .filterNot { info -> info.isSystemApplication }
    }

    suspend fun getPackageInfo(packageName: String): PackageInfo? = withContext(context = ioDispatcher) {
        val flags = GET_META_DATA or GET_PERMISSIONS or GET_SERVICES or GET_RECEIVERS

        return@withContext packageManager
            .getPackageInfoCompat(packageName = packageName, flags = flags)
            .takeUnless { info -> info.applicationInfo.isSystemApplication }
    }

    suspend fun getApplicationName(info: ApplicationInfo): String = withContext(context = ioDispatcher) {
        return@withContext packageManager
            .getApplicationLabel(info)
            .toString()
    }
}
