package com.kma.malwarescanner.core.data.util

import android.content.res.AssetManager
import com.google.gson.Gson
import com.kma.malwarescanner.core.domain.data.model.Application
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.async
import kotlinx.coroutines.withContext
import org.tensorflow.lite.Interpreter
import java.io.FileInputStream
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel.MapMode
import javax.inject.Inject
import javax.inject.Named

class ApplicationClassifier @Inject constructor(
    private val assetManager: AssetManager,

    @Named("default")
    private val defaultDispatcher: CoroutineDispatcher,

    @Named("io")
    private val ioDispatcher: CoroutineDispatcher
) {
    private lateinit var interpreter: Interpreter

    private lateinit var permissions: List<String>

    private lateinit var labels: List<String>

    suspend fun classify(vararg applications: Application): List<String?> = withContext(defaultDispatcher) {
        // Pre-processing:
        val interpreter = async { getInterpreter(fileName = MODEL_FILE_NAME) }
        val input = async { applications.toList().asInput() }
        val labels = async { getLabels() }

        // Define an array to store the model output.
        val output = Array(size = applications.size) { FloatArray(size = MODEL_OUTPUT_SIZE) }

        // Run inference with the input data.
        interpreter.await().run(input.await(), output)

        // Post-processing: find the digit that has the highest probability
        return@withContext output
            .map { it.indices.maxByOrNull { index -> it[index] } ?: -1 }
            .map { index -> labels.await().getOrNull(index) }
    }

    private suspend fun getInterpreter(fileName: String): Interpreter {
        if (this::interpreter.isInitialized) {
            return interpreter
        }

        val model = getModel(fileName)
        val option = Interpreter.Options().setNumThreads(INTERPRETER_NUMBER_THREADS)

        interpreter = Interpreter(model, option)
        return interpreter
    }

    private suspend fun getModel(fileName: String): MappedByteBuffer = withContext(ioDispatcher) {
        val fileDescriptor = assetManager.openFd(fileName)
        val inputStream = FileInputStream(fileDescriptor.fileDescriptor)
        val fileChannel = inputStream.channel
        val startOffset = fileDescriptor.startOffset
        val declaredLength = fileDescriptor.declaredLength

        return@withContext fileChannel.map(MapMode.READ_ONLY, startOffset, declaredLength)
    }

    private suspend fun List<Application>.asInput(): Array<Array<Array<FloatArray>>> = withContext(defaultDispatcher) {
        val permissions = async { getPermissions() }
        val input = mutableListOf<List<Array<FloatArray>>>()
        var buffer: List<FloatArray>

        forEach { application ->
            buffer = List(size = 900) { FloatArray(size = 1) { 0f } }
            application.permissions
                .map { permission -> permission.split(".").last() }
                .map { permission -> permissions.await().indexOf(permission) }
                .filter { index -> index != -1 }
                .forEach { index -> buffer[index][0] = 1f }
            input.add(buffer.chunked(size = 30).map { it.toTypedArray() })
        }
        return@withContext input
            .map { it.toTypedArray() }
            .toTypedArray()
    }

    private suspend fun getPermissions(): List<String> = withContext(ioDispatcher) {
        if (this@ApplicationClassifier::permissions.isInitialized) {
            return@withContext permissions
        }

        val content = assetManager.open(MODEL_PERMISSIONS_FILE_NAME)
            .bufferedReader()
            .use { buffer -> buffer.readText() }
        val data = Gson().fromJson(content, List::class.java)

        permissions = data.map { it as String }
        return@withContext permissions
    }

    private suspend fun getLabels(): List<String> = withContext(ioDispatcher) {
        if (this@ApplicationClassifier::labels.isInitialized) {
            return@withContext labels
        }

        val content = assetManager.open(MODEL_LABELS_FILE_NAME)
            .bufferedReader()
            .use { buffer -> buffer.readText() }
        val data = Gson().fromJson(content, List::class.java)

        labels = data.map { it as String }
        return@withContext labels
    }

    companion object {
        private const val INTERPRETER_NUMBER_THREADS = 2

        private const val MODEL_FILE_NAME = "models/model.tflite"
        private const val MODEL_PERMISSIONS_FILE_NAME = "models/permissions.json"
        private const val MODEL_LABELS_FILE_NAME = "models/labels.json"
        private const val MODEL_OUTPUT_SIZE = 228
    }
}
