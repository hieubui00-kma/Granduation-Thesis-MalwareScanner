package com.kma.malwarescanner.core.data.local.source

import android.content.res.AssetManager
import com.kma.malwarescanner.core.data.local.dao.TensorModelDao
import com.kma.malwarescanner.core.data.local.entity.TensorModelEntity
import com.kma.malwarescanner.core.data.util.copyTo
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileInputStream
import java.io.FileNotFoundException
import java.io.InputStream
import java.nio.MappedByteBuffer
import java.nio.channels.FileChannel
import java.util.Date
import javax.inject.Inject
import javax.inject.Named

class TensorModelLocalDataSource @Inject constructor(
    private val tensorModelDao: TensorModelDao,

    @Named("files")
    private val filesStorage: File,

    private val assetManager: AssetManager,

    @Named("io")
    private val ioDispatcher: CoroutineDispatcher
) {

    suspend fun getTensorModels(): List<TensorModelEntity> = withContext(context = ioDispatcher) {
        return@withContext tensorModelDao.findAll()
    }

    suspend fun saveTensorModel(
        id: String,
        version: String,
        createdAt: Date
    ): TensorModelEntity = withContext(context = ioDispatcher) {
        val tensorModel = TensorModelEntity(id = id, version = version, createdAt = createdAt)

        tensorModelDao.insert(tensorModel = tensorModel)
        return@withContext tensorModel
    }

    suspend fun saveTensorModelSource(
        source: InputStream,
        name: String
    ): File = withContext(context = ioDispatcher) {
        val file = File(filesStorage, "$name.tflite")

        if (file.exists()) {
            throw FileAlreadyExistsException(file)
        }

        source.copyTo(file = file, context = ioDispatcher)
        return@withContext file
    }

    suspend fun getTensorModel(
        tensorModelId: String
    ): TensorModelEntity? = withContext(context = ioDispatcher) {
        return@withContext tensorModelDao.findById(tensorModelId = tensorModelId)
    }

    suspend fun getTensorModelSource(name: String): MappedByteBuffer? = withContext(context = ioDispatcher) {
        val fileName = "$name.tflite"
        val file = File(filesStorage, fileName).takeIf { file -> file.exists() }
        val fileChannel: FileChannel
        val startOffset: Long
        val declaredLength: Long

        when {
            file != null -> {
                fileChannel = file.inputStream().channel
                startOffset = 0
                declaredLength = fileChannel.size()
            }

            else -> {
                val fileDescriptor = assetManager
                    .runCatching { openFd(fileName) }
                    .getOrNull()
                    ?: return@withContext null
                val inputStream = FileInputStream(fileDescriptor.fileDescriptor)

                fileChannel = inputStream.channel
                startOffset = fileDescriptor.startOffset
                declaredLength = fileDescriptor.declaredLength
            }
        }
        return@withContext fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength)
    }

    suspend fun deleteTensorModel(tensorModelId: String): Unit = withContext(context = ioDispatcher) {
        tensorModelDao.deleteById(tensorModelId = tensorModelId)
    }

    suspend fun deleteTensorModelSource(name: String): Unit = withContext(context = ioDispatcher) {
        val fileName = "$name.tflite"

        File(filesStorage, fileName)
            .takeIf { file -> file.exists() }
            ?.delete()
            ?: throw FileNotFoundException("$name could not be found!")
    }
}
