package com.kma.malwarescanner.core.data.repository

import com.kma.malwarescanner.core.data.model.Permission
import com.kma.malwarescanner.core.domain.data.model.MalwareType
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.async
import kotlinx.coroutines.withContext
import org.tensorflow.lite.Interpreter
import javax.inject.Inject
import javax.inject.Named

class MalwareRepository @Inject constructor(
    private val tensorModelRepository: TensorModelRepository,

    private val permissionRepository: PermissionRepository,

    private val malwareTypeRepository: MalwareTypeRepository,

    @Named("default")
    private val defaultDispatcher: CoroutineDispatcher
) {

    suspend fun getMalwareTypes(
        permissions: List<String>
    ): List<MalwareType?> = withContext(context = defaultDispatcher) {
        // Pre-processing:
        val permissionsAsync = async { permissionRepository.getPermissions() }
        val interpreterAsync = async {
            val model = tensorModelRepository.getClassifyByPermissionsModel()
            val options = Interpreter.Options().setNumThreads(INTERPRETER_NUMBER_THREADS)

            return@async Interpreter(model, options)
        }
        val malwareTypesAsync = async { malwareTypeRepository.getMalwareTypes() }
        val input = arrayOf(
            permissions.toData(permissions = permissionsAsync.await())
        )

        // Define an array to store the model output.
        val output = arrayOf(
            FloatArray(size = CLASSIFY_BY_PERMISSIONS_MODEL_OUTPUT_SIZE)
        )

        // Run inference with the input data.
        interpreterAsync.await().use { interpreter -> interpreter.run(input, output) }

        // Post-processing: find the digit that has the highest probability
        return@withContext output
            .map { result -> result.indices.maxByOrNull { index -> result[index] } ?: -1 }
            .map { id -> malwareTypesAsync.await().firstOrNull { type -> type.id == id + 1 } }
    }

    private suspend fun List<String>.toData(
        permissions: List<Permission>
    ): Array<Array<FloatArray>> = withContext(context = defaultDispatcher) {
        val buffer = List(size = 900) { FloatArray(size = 1) { 0f } }

        // Map all the requested permissions of the app to their unique names and mark it in buffer with value 1
        this@toData
            .map { permission -> permission.split(".").last() }
            .mapNotNull { name -> permissions[name] }
            .forEach { permission -> buffer[permission.id][0] = 1f }

        // Split the buffer into a 2D array of size 30x30
        return@withContext buffer
            .chunked(size = 30)
            .map { splitBuffer -> splitBuffer.toTypedArray() }
            .toTypedArray()
    }

    private operator fun List<Permission>.get(name: String): Permission? {
        return firstOrNull { permission -> permission.name == name }
    }

    companion object {
        private const val INTERPRETER_NUMBER_THREADS = 4
        private const val CLASSIFY_BY_PERMISSIONS_MODEL_OUTPUT_SIZE = 228
    }
}
