package com.kma.malwarescanner.core.data.repository

import com.kma.malwarescanner.core.data.local.entity.TensorModelEntity
import com.kma.malwarescanner.core.data.local.source.TensorModelLocalDataSource
import com.kma.malwarescanner.core.data.model.asModel
import com.kma.malwarescanner.core.data.remote.model.TensorModelDetailsRemoteModel
import com.kma.malwarescanner.core.data.remote.source.TensorModelRemoteDataSource
import com.kma.malwarescanner.core.data.remote.source.TensorModelRemoteDataSource.Companion.TENSOR_MODEL_INPUT_FORMAT_APK
import com.kma.malwarescanner.core.domain.data.model.TensorModel
import com.kma.malwarescanner.core.domain.data.repository.TensorModelRepository
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.supervisorScope
import java.nio.MappedByteBuffer
import javax.inject.Inject

class TensorModelRepositoryImpl @Inject constructor(
    private val remoteDataSource: TensorModelRemoteDataSource,

    private val localDataSource: TensorModelLocalDataSource,

    private val tensorInputRepository: TensorInputRepository,

    private val tensorOutputRepository: TensorOutputRepository
) : TensorModelRepository {

    override suspend fun getTensorModels(): List<TensorModel> {
        return localDataSource
            .getTensorModels()
            .map(TensorModelEntity::asModel)
    }

    override suspend fun getTensorModelDetails(
        tensorModelId: String
    ): TensorModel? = coroutineScope {
        val tensorModel = getLocalTensorModelDetails(tensorModelId = tensorModelId)

        if (tensorModel != null) {
            return@coroutineScope tensorModel
        }

        val tensorInput = async { tensorInputRepository.getTensorInput(tensorModelId = tensorModelId) }
        val tensorModelDetails = remoteDataSource.getTensorModelDetails(tensorModelId = tensorModelId)

        return@coroutineScope tensorModelDetails
            ?.let { return@let saveTensorModel(tensorModel = tensorModelDetails) }
            ?.asModel(input = tensorInput.await(), output = tensorModelDetails.output)
    }

    private suspend fun getLocalTensorModelDetails(
        tensorModelId: String
    ): TensorModel? = coroutineScope {
        val tensorModelEntity = localDataSource
            .getTensorModel(tensorModelId = tensorModelId)
            ?: return@coroutineScope null

        return@coroutineScope with(receiver = tensorModelEntity) {
            val tensorInput = async { tensorInputRepository.getTensorInput(tensorModelId = id) }
            val tensorOutput = async { tensorOutputRepository.getTensorOutput(tensorModelId = id) }

            return@with asModel(input = tensorInput.await(), output = tensorOutput.await())
        }
    }

    private suspend fun saveTensorModel(tensorModel: TensorModelDetailsRemoteModel): TensorModelEntity {
        return with(tensorModel) {
            val tensorModelEntity = localDataSource.saveTensorModel(
                id = id, version = version, createdAt = createdAt
            )

            tensorOutputRepository.saveTensorOutput(tensorModelId = id, tensorOutput = output)
            return@with tensorModelEntity
        }
    }

    override suspend fun getTensorModelSource(tensorModelId: String): MappedByteBuffer? {
        var source = localDataSource.getTensorModelSource(name = tensorModelId)

        if (source == null) {
            val inputStream = remoteDataSource
                .getTensorModelSource(tensorModelId = tensorModelId)
                ?: return null

            localDataSource.runCatching { saveTensorModelSource(source = inputStream, name = tensorModelId) }
            source = localDataSource.getTensorModelSource(name = tensorModelId)
        }
        return source
    }

    override suspend fun upgradeTensorModel(): Unit = coroutineScope {
        val currentTensorModel = async { getTensorModels().firstOrNull() }
        val newestTensorModel = remoteDataSource
            .getTensorModels(inputFormat = TENSOR_MODEL_INPUT_FORMAT_APK, limit = 1)
            .firstOrNull()
            ?: return@coroutineScope
        val currentTensorModelId = currentTensorModel.await()?.id

        if (currentTensorModelId == newestTensorModel.id) {
            return@coroutineScope
        }

        val tensorModel = async { getTensorModelDetails(tensorModelId = newestTensorModel.id) }
        val source = async { getTensorModelSource(tensorModelId = newestTensorModel.id) }
        val isFailed = tensorModel.await() == null || source.await() == null

        when {
            isFailed -> deleteTensorModel(tensorModelId = newestTensorModel.id)
            currentTensorModelId != null -> deleteTensorModel(tensorModelId = currentTensorModelId)
        }
    }

    private suspend fun deleteTensorModel(tensorModelId: String): Unit = supervisorScope {
        listOf(
            async { localDataSource.deleteTensorModel(tensorModelId = tensorModelId) },
            async { tensorInputRepository.removeTensorInput(tensorModelId = tensorModelId) },
            async { tensorOutputRepository.removeTensorOutput(tensorModelId = tensorModelId) },
            async { localDataSource.deleteTensorModelSource(name = tensorModelId) }
        ).awaitAll()
    }
}
