package com.kma.malwarescanner.core.data.repository

import com.kma.malwarescanner.core.data.local.entity.TensorModelEntity
import com.kma.malwarescanner.core.data.local.source.TensorModelLocalDataSource
import com.kma.malwarescanner.core.data.model.asModel
import com.kma.malwarescanner.core.data.remote.model.TensorModelDetailsRemoteModel
import com.kma.malwarescanner.core.data.remote.source.TensorModelRemoteDataSource
import com.kma.malwarescanner.core.domain.data.model.TensorModel
import com.kma.malwarescanner.core.domain.data.repository.TensorModelRepository
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import java.io.File
import javax.inject.Inject

class TensorModelRepositoryImpl @Inject constructor(
    private val tensorModelRemoteDataSource: TensorModelRemoteDataSource,

    private val tensorModelLocalDataSource: TensorModelLocalDataSource,

    private val tensorInputRepository: TensorInputRepository,

    private val tensorOutputRepository: TensorOutputRepository
) : TensorModelRepository {

    override suspend fun getTensorModels(): List<TensorModel> {
        return tensorModelLocalDataSource
            .getTensorModels()
            .map { tensorModelEntity ->
                val tensorInput = tensorInputRepository.getTensorInput(tensorModelId = tensorModelEntity.id)
                val tensorOutput = tensorOutputRepository.getTensorOutput(tensorModelId = tensorModelEntity.id)

                return@map tensorModelEntity.asModel(input = tensorInput, output = tensorOutput)
            }
    }

    override suspend fun getTensorModelDetails(tensorModelId: String): TensorModel? {
        var tensorModelEntity = tensorModelLocalDataSource.getTensorModel(tensorModelId = tensorModelId)
        val tensorInput: List<String>
        val tensorOutput: List<String>

        if (tensorModelEntity != null) {
            tensorInput = tensorInputRepository.getTensorInput(tensorModelId = tensorModelEntity.id)
            tensorOutput = tensorOutputRepository.getTensorOutput(tensorModelId = tensorModelEntity.id)
        } else {
            val tensorModel = tensorModelRemoteDataSource
                .getTensorModelDetails(tensorModelId = tensorModelId)
                ?: return null

            tensorModelEntity = saveTensorModel(tensorModel = tensorModel)
            tensorInput = tensorModel.input
            tensorOutput = tensorModel.output
        }
        return tensorModelEntity.asModel(input = tensorInput, output = tensorOutput)
    }

    private suspend fun saveTensorModel(
        tensorModel: TensorModelDetailsRemoteModel
    ): TensorModelEntity {
        val tensorModelEntity = tensorModelLocalDataSource.saveTensorModel(
            id = tensorModel.id,
            version = tensorModel.version,
            createdAt = tensorModel.createdAt
        )

        tensorInputRepository.saveTensorInput(
            tensorModelId = tensorModel.id,
            tensorInput = tensorModel.input
        )
        tensorOutputRepository.saveTensorOutput(
            tensorModelId = tensorModel.id,
            tensorOutput = tensorModel.output
        )
        return tensorModelEntity
    }

    override suspend fun getTensorModelSource(tensorModelId: String): File = coroutineScope {
        val name = "$tensorModelId.tflite"
        var source = tensorModelLocalDataSource.getTensorModelSource(name = name)

        if (source != null) {
            return@coroutineScope source
        }

        val inputStream = tensorModelRemoteDataSource.getTensorModelSource(tensorModelId = tensorModelId)
        source = tensorModelLocalDataSource.saveTensorModelSource(source = inputStream, name = name)

        return@coroutineScope source
    }

    override suspend fun upgradeTensorModel(): Unit = coroutineScope {
        val currentTensorModel = async { getTensorModels().firstOrNull() }
        val newestTensorModel = tensorModelRemoteDataSource
            .getTensorModels()
            .firstOrNull()
            ?: return@coroutineScope
        val currentTensorModelId = currentTensorModel.await()?.id

        if (currentTensorModelId == newestTensorModel.id) {
            return@coroutineScope
        }

        listOf(
            async { getTensorModelDetails(tensorModelId = newestTensorModel.id) },
            async { getTensorModelSource(tensorModelId = newestTensorModel.id) }
        ).awaitAll()

        currentTensorModelId?.let {
            deleteTensorModel(tensorModelId = currentTensorModelId)
        }
    }

    private suspend fun deleteTensorModel(tensorModelId: String): Unit = coroutineScope {
        listOf(
            async { tensorModelLocalDataSource.deleteTensorModel(tensorModelId = tensorModelId) },
            async { tensorInputRepository.removeTensorInput(tensorModelId = tensorModelId) },
            async { tensorOutputRepository.removeTensorOutput(tensorModelId = tensorModelId) },
            async { tensorModelLocalDataSource.deleteTensorModelSource(name = "$tensorModelId.tflite") }
        ).awaitAll()
    }
}
