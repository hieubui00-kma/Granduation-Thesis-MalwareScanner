package com.kma.malwarescanner.core.data.repository

import com.kma.malwarescanner.core.data.local.entity.TensorModelEntity
import com.kma.malwarescanner.core.data.local.source.TensorModelLocalDataSource
import com.kma.malwarescanner.core.data.model.asModel
import com.kma.malwarescanner.core.data.remote.model.TensorModelDetailsRemoteModel
import com.kma.malwarescanner.core.data.remote.source.TensorModelRemoteDataSource
import com.kma.malwarescanner.core.domain.data.model.TensorModel
import com.kma.malwarescanner.core.domain.data.repository.TensorModelRepository
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import java.nio.MappedByteBuffer
import javax.inject.Inject

class TensorModelRepositoryImpl @Inject constructor(
    private val tensorModelRemoteDataSource: TensorModelRemoteDataSource,

    private val tensorModelLocalDataSource: TensorModelLocalDataSource,

    private val tensorInputRepository: TensorInputRepository,

    private val tensorOutputRepository: TensorOutputRepository
) : TensorModelRepository {

    override suspend fun getTensorModels(): List<TensorModel> {
        return tensorModelLocalDataSource
            .getTensorModels()
            .map(TensorModelEntity::asModel)
    }

    override suspend fun getTensorModelDetails(tensorModelId: String): TensorModel? {
        val tensorModelEntity = tensorModelLocalDataSource.getTensorModel(tensorModelId = tensorModelId)

        if (tensorModelEntity != null) {
            return with(tensorModelEntity) {
                val tensorInput = tensorInputRepository.getTensorInput(tensorModelId = id)
                val tensorOutput = tensorOutputRepository.getTensorOutput(tensorModelId = id)

                return@with asModel(input = tensorInput, output = tensorOutput)
            }
        }

        return tensorModelRemoteDataSource
            .getTensorModelDetails(tensorModelId = tensorModelId)
            ?.let { tensorModel ->
                saveTensorModel(tensorModel = tensorModel).asModel(
                    input = tensorModel.input,
                    output = tensorModel.output
                )
            }
    }

    private suspend fun saveTensorModel(tensorModel: TensorModelDetailsRemoteModel): TensorModelEntity {
        return with(tensorModel) {
            val tensorModelEntity = tensorModelLocalDataSource.saveTensorModel(
                id = id, version = version, createdAt = createdAt
            )

            tensorInputRepository.saveTensorInput(tensorModelId = id, tensorInput = input)
            tensorOutputRepository.saveTensorOutput(tensorModelId = id, tensorOutput = output)
            return@with tensorModelEntity
        }
    }

    override suspend fun getTensorModelSource(tensorModelId: String): MappedByteBuffer? = coroutineScope {
        var source = tensorModelLocalDataSource.getTensorModelSource(name = tensorModelId)

        if (source != null) {
            return@coroutineScope source
        }

        val inputStream = tensorModelRemoteDataSource
            .getTensorModelSource(tensorModelId = tensorModelId)
            ?: return@coroutineScope null

        tensorModelLocalDataSource.saveTensorModelSource(source = inputStream, name = tensorModelId)
        source = tensorModelLocalDataSource.getTensorModelSource(name = tensorModelId)

        return@coroutineScope source
    }

    override suspend fun upgradeTensorModel(): Unit = coroutineScope {
        val currentTensorModel = async { getTensorModels().firstOrNull() }
        val newestTensorModel = tensorModelRemoteDataSource
            .getTensorModels()
            .firstOrNull()
            ?: return@coroutineScope
        val currentTensorModelId = currentTensorModel.await()?.id

        if (currentTensorModelId == newestTensorModel.id) {
            return@coroutineScope
        }

        val tensorModel = async { getTensorModelDetails(tensorModelId = newestTensorModel.id) }
        val source = async { getTensorModelSource(tensorModelId = newestTensorModel.id) }
        val isFailed = arrayOf(tensorModel.await() == null, source.await() == null).any { result -> result }

        when {
            isFailed -> deleteTensorModel(tensorModelId = newestTensorModel.id)
            currentTensorModelId != null -> deleteTensorModel(tensorModelId = currentTensorModelId)
        }
    }

    private suspend fun deleteTensorModel(tensorModelId: String): Unit = coroutineScope {
        listOf(
            async { tensorModelLocalDataSource.deleteTensorModel(tensorModelId = tensorModelId) },
            async { tensorInputRepository.removeTensorInput(tensorModelId = tensorModelId) },
            async { tensorOutputRepository.removeTensorOutput(tensorModelId = tensorModelId) },
            async { tensorModelLocalDataSource.deleteTensorModelSource(name = tensorModelId) }
        ).awaitAll()
    }
}
