package com.kma.malwarescanner.core.data.repository

import com.kma.malwarescanner.core.data.local.entity.TensorModelEntity
import com.kma.malwarescanner.core.data.local.source.TensorModelLocalDataSource
import com.kma.malwarescanner.core.data.model.asModel
import com.kma.malwarescanner.core.data.remote.model.TensorModelDetailsRemoteModel
import com.kma.malwarescanner.core.data.remote.model.TensorModelRemoteModel
import com.kma.malwarescanner.core.data.remote.source.TensorModelRemoteDataSource
import com.kma.malwarescanner.core.domain.data.model.TensorModel
import com.kma.malwarescanner.core.domain.data.repository.TensorModelRepository
import kotlinx.coroutines.coroutineScope
import java.io.File
import javax.inject.Inject

class TensorModelRepositoryImpl @Inject constructor(
    private val tensorModelRemoteDataSource: TensorModelRemoteDataSource,

    private val tensorModelLocalDataSource: TensorModelLocalDataSource,

    private val tensorInputRepository: TensorInputRepository,

    private val tensorOutputRepository: TensorOutputRepository
) : TensorModelRepository {

    override suspend fun getTensorModels(): List<TensorModel> {
        return tensorModelRemoteDataSource
            .getTensorModels()
            .map(TensorModelRemoteModel::asModel)
    }

    override suspend fun getTensorModelDetails(tensorModelId: String): TensorModel? {
        var tensorModelEntity = tensorModelLocalDataSource.getTensorModel(tensorModelId = tensorModelId)
        val tensorInput: List<String>
        val tensorOutput: List<String>

        if (tensorModelEntity != null) {
            tensorInput = tensorInputRepository.getTensorInput(tensorModelId = tensorModelEntity.id)
            tensorOutput = tensorOutputRepository.getTensorOutput(tensorModelId = tensorModelEntity.id)
        } else {
            val tensorModel = tensorModelRemoteDataSource
                .getTensorModelDetails(tensorModelId = tensorModelId)
                ?: return null

            tensorModelEntity = saveTensorModelDetails(tensorModel = tensorModel)
            tensorInput = tensorModel.input
            tensorOutput = tensorModel.output
        }
        return tensorModelEntity.asModel(input = tensorInput, output = tensorOutput)
    }

    private suspend fun saveTensorModelDetails(
        tensorModel: TensorModelDetailsRemoteModel
    ): TensorModelEntity {
        val tensorModelEntity = tensorModelLocalDataSource.saveTensorModel(
            id = tensorModel.id,
            version = tensorModel.version,
            createdAt = tensorModel.createdAt
        )

        tensorInputRepository.saveTensorInput(
            tensorModelId = tensorModel.id,
            tensorInput = tensorModel.input
        )
        tensorOutputRepository.saveTensorOutput(
            tensorModelId = tensorModel.id,
            tensorOutput = tensorModel.output
        )
        return tensorModelEntity
    }

    override suspend fun getTensorModelSource(tensorModelId: String): File = coroutineScope {
        val name = "$tensorModelId.tflite"
        var source = tensorModelLocalDataSource.getTensorModelSource(name = name)

        if (source != null) {
            return@coroutineScope source
        }

        val inputStream = tensorModelRemoteDataSource.getTensorModelSource(tensorModelId = tensorModelId)
        source = tensorModelLocalDataSource.saveTensorModelSource(source = inputStream, name = name)

        return@coroutineScope source
    }

    override suspend fun removeTensorModelSource(tensorModelId: String) {
        tensorModelLocalDataSource.deleteTensorModelSource(name = "$tensorModelId.tflite")
    }
}
