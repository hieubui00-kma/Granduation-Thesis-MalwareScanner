package com.kma.malwarescanner.core.data.repository

import android.net.Uri
import com.kma.apktool.ApkFile
import com.kma.malwarescanner.core.data.local.source.ApplicationLocalDataSource
import com.kma.malwarescanner.core.data.model.asModel
import com.kma.malwarescanner.core.domain.data.model.Application
import com.kma.malwarescanner.core.domain.data.repository.ApplicationRepository
import com.kma.malwarescanner.core.domain.data.repository.TensorModelRepository
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext
import org.tensorflow.lite.Interpreter
import java.io.File
import java.util.Date
import javax.inject.Inject
import javax.inject.Named
import kotlin.math.roundToInt
import kotlin.math.sqrt
import timber.log.Timber

class ApplicationRepositoryImpl @Inject constructor(
    private val applicationLocalDataSource: ApplicationLocalDataSource,

    private val tensorModelRepository: TensorModelRepository,

    @Named("default")
    private val defaultDispatcher: CoroutineDispatcher
) : ApplicationRepository {

    override suspend fun getInstalledApplications(): List<Application> {
        return applicationLocalDataSource
            .getInstalledApplications()
            .map { applicationInfo ->
                val name = applicationLocalDataSource.getApplicationName(info = applicationInfo)

                return@map applicationInfo.asModel(name = name)
            }
    }

    override suspend fun getApplication(sourceDir: String): Application = coroutineScope {
        val apkFile = ApkFile(path = sourceDir)
        val metadata = withContext(context = defaultDispatcher) { apkFile.apkMeta }
        val installDate = async { getInstallDate(packageName = metadata.packageName) }
        val updateDate = async { getUpdateDate(packageName = metadata.packageName) }
        val malwareType = async { getMalwareType(apkFile = apkFile) }

        return@coroutineScope metadata.asModel(
            sourceDir = sourceDir,
            installDate = installDate.await(),
            updatedDate = updateDate.await(),
            malwareType = malwareType.await()
        )
    }

    private suspend fun getInstallDate(packageName: String): Date? {
        return applicationLocalDataSource
            .getInstallTime(packageName = packageName)
            ?.let { installTime -> Date(installTime) }
    }

    private suspend fun getUpdateDate(packageName: String): Date? {
        return applicationLocalDataSource
            .getUpdateTime(packageName = packageName)
            ?.let { updateTime -> Date(updateTime) }
    }

    private suspend fun getMalwareType(apkFile: ApkFile) = withContext(context = defaultDispatcher) {
        val tensorModel = tensorModelRepository.getTensorModels()
            .firstOrNull()
            ?.let { tensorModel -> tensorModelRepository.getTensorModelDetails(tensorModelId = tensorModel.id) }
            ?: return@withContext null
        val interpreter = async {
            val source = tensorModelRepository
                .getTensorModelSource(tensorModelId = tensorModel.id)
                ?: return@async null
            val options = Interpreter.Options().setNumThreads(INTERPRETER_NUMBER_THREADS)

            return@async Interpreter(source, options)
        }

        // Pre-processing
        Timber.d("Pre-processing...")
        val input = arrayOf(apkFile.toData(tensorInput = tensorModel.input))
        val output = arrayOf(FloatArray(size = 228))

        // Run inference with the input data.
        Timber.d("Run inference with the input data...")
        interpreter.await()?.run(input, output) ?: return@withContext null
        interpreter.await()?.close()

        // Post-processing: find the digit that has the highest probability
        Timber.d("Post-processing...")
        return@withContext output
            .map { result -> result.indices.maxByOrNull { index -> result[index] } }
            .map { index -> tensorModel.output.getOrNull(index = index ?: -1) }
            .firstOrNull()
    }

    private suspend fun ApkFile.toData(tensorInput: List<String>) = withContext(context = defaultDispatcher) {
        val permissions = apkMeta
            .usesPermissions
            .map { permission -> permission.split(".").last().uppercase() }
        val apis = applicationLocalDataSource.getAPIs(path = this@toData.path)
        val buffer = tensorInput
            .map { input -> if (input in permissions || input in apis) 1f else 0f }
            .map { value -> floatArrayOf(value) }
        val matrixSize = sqrt(x = buffer.size.toDouble()).roundToInt()
        val padding = Array(size = matrixSize * matrixSize - buffer.size) { floatArrayOf(0f) }

        return@withContext buffer
            .plus(elements = padding)
            .chunked(size = matrixSize)
            .map { splitBuffer -> splitBuffer.toTypedArray() }
            .toTypedArray()
    }

    override suspend fun getApplicationSource(uri: Uri): File? {
        return applicationLocalDataSource.getSource(uri = uri)
    }

    companion object {
        private const val INTERPRETER_NUMBER_THREADS = 4
    }
}
