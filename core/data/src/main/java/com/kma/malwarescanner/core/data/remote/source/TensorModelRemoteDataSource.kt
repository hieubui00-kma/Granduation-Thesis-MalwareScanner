package com.kma.malwarescanner.core.data.remote.source

import com.kma.malwarescanner.core.data.remote.model.TensorModelDetailsRemoteModel
import com.kma.malwarescanner.core.data.remote.model.TensorModelRemoteModel
import com.kma.malwarescanner.core.data.remote.request.KSecurityService
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.InputStream
import javax.inject.Inject
import javax.inject.Named

class TensorModelRemoteDataSource @Inject constructor(
    private val kSecurityService: KSecurityService,

    @Named("io")
    private val ioDispatcher: CoroutineDispatcher
) {

    suspend fun getTensorModels(
        type: String,
        page: Int = 1,
        limit: Int = 20
    ): List<TensorModelRemoteModel> = withContext(context = ioDispatcher) {
        val response = runCatching { kSecurityService.getTensorModels(type = type, page = page, limit = limit) }
            .onFailure { exception -> Timber.w(message = exception.message) }
            .getOrNull()

        return@withContext response?.data.orEmpty()
    }

    suspend fun getTensorModelDetails(
        tensorModelId: String
    ): TensorModelDetailsRemoteModel? = withContext(context = ioDispatcher) {
        val response = runCatching { kSecurityService.getTensorModelDetails(tensorModelId = tensorModelId) }
            .onFailure { exception -> Timber.w(message = exception.message) }
            .getOrNull()

        return@withContext response?.data
    }

    suspend fun getTensorModelSource(
        tensorModelId: String
    ): InputStream? = withContext(context = ioDispatcher) {
        val response = runCatching { kSecurityService.getTensorModelSource(tensorModelId = tensorModelId) }
            .onFailure { exception -> Timber.w(message = exception.message) }
            .getOrNull()

        return@withContext response?.byteStream()
    }

    companion object {
        internal const val TENSOR_MODEL_TYPE_HDF5 = "HDF5/H5"
    }
}
