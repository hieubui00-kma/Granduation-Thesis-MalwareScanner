package com.kma.malwarescanner.core.data.remote.source

import com.kma.malwarescanner.core.data.remote.model.TensorModelDetailsRemoteModel
import com.kma.malwarescanner.core.data.remote.model.TensorModelRemoteModel
import com.kma.malwarescanner.core.data.remote.request.KSecurityService
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.withContext
import timber.log.Timber
import java.io.InputStream
import javax.inject.Inject
import javax.inject.Named

class TensorModelRemoteDataSource @Inject constructor(
    private val kSecurityService: KSecurityService,

    @Named("io")
    private val ioDispatcher: CoroutineDispatcher
) {

    suspend fun getTensorModels(): List<TensorModelRemoteModel> = withContext(context = ioDispatcher) {
        val response = runCatching { kSecurityService.getTensorModels() }
            .onFailure { exception -> Timber.d(message = exception.message) }
            .getOrNull()

        return@withContext response?.data.orEmpty()
    }

    suspend fun getTensorModelDetails(
        tensorModelId: String
    ): TensorModelDetailsRemoteModel? = withContext(context = ioDispatcher) {
        val response = runCatching { kSecurityService.getTensorModelDetails(tensorModelId = tensorModelId) }
            .onFailure { exception -> Timber.d(message = exception.message) }
            .getOrNull()

        return@withContext response?.data
    }

    suspend fun getTensorModelSource(tensorModelId: String): InputStream? = withContext(context = ioDispatcher) {
        val response = runCatching { kSecurityService.getTensorModelSource(tensorModelId = tensorModelId) }
            .onFailure { exception -> Timber.d(message = exception.message) }
            .getOrNull()

        return@withContext response?.byteStream()
    }
}
