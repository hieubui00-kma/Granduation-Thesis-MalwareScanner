package com.kma.apktool

import com.kma.apktool.data.model.isInitialize
import com.kma.apktool.util.asMethod
import com.kma.apktool.util.disassemble
import com.kma.apktool.util.isCommand
import com.kma.apktool.util.isSmali
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.FlowPreview
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.filterNot
import kotlinx.coroutines.flow.flatMapConcat
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.withContext
import net.dongliu.apk.parser.AbstractApkFile
import net.dongliu.apk.parser.bean.ApkSignStatus
import timber.log.Timber
import java.io.File
import java.nio.ByteBuffer
import java.nio.channels.FileChannel
import java.util.zip.ZipFile

class ApkFile : AbstractApkFile {
    private val zipFile: ZipFile by lazy { ZipFile(file) }

    private val fileChannel: FileChannel by lazy { file.inputStream().channel }

    private val file: File

    val path: String
        get() = file.path

    constructor(path: String) : super() {
        this.file = File(path)
    }

    constructor(file: File) : super() {
        this.file = file
    }

    override fun getAllCertificateData(): List<CertificateFile> {
        val certificateFiles = mutableListOf<CertificateFile>()
        val certificatePatterns = arrayOf(".RSA", ".DSA")
        val entries = zipFile.entries()

        while (entries.hasMoreElements()) {
            val entry = entries.nextElement()
                .takeUnless { entry -> entry.isDirectory }
                ?: continue
            val name = entry.name.uppercase()
            val isCertificate = certificatePatterns.any { pattern -> name.endsWith(suffix = pattern) }

            if (isCertificate) {
                val byteArray = zipFile
                    .getInputStream(entry)
                    .use { inputStream -> inputStream.readBytes() }

                certificateFiles += CertificateFile(name, byteArray)
            }
        }
        return certificateFiles
    }

    override fun getFileData(path: String?): ByteArray? {
        val entry = zipFile.getEntry(path) ?: return null

        return zipFile
            .getInputStream(entry)
            .use { inputStream -> inputStream.readBytes() }
    }

    override fun fileData(): ByteBuffer {
        return fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size())
    }

    @Deprecated(message = "Using google official ApkVerifier of apksig lib instead.")
    override fun verifyApk(): ApkSignStatus {
        return when {
            zipFile.getEntry(ENTRY_META_INF) == null -> ApkSignStatus.notSigned
            else -> ApkSignStatus.signed
        }
    }

    override fun close() {
        super.close()
        fileChannel.close()
        zipFile.close()
    }

    suspend fun getAPIs(cache: File): List<String> = withContext(context = Dispatchers.Default) {
        val outDir = File(cache, file.nameWithoutExtension)

        try {
            Timber.d(message = "Disassemble...")
            outDir.deleteRecursively()
            outDir.mkdirs()
            file.disassemble(outDir = outDir)

            Timber.d(message = "Parsing...")
            val sources = outDir.listFiles() ?: return@withContext emptyList()

            return@withContext sources.asFlow()
                .map { source -> async { parseSource(source = source) } }
                .toList()
                .awaitAll()
                .flatten()
                .distinct()
        } finally {
            Timber.d(message = "Clear cache...")
            outDir.deleteRecursively() // Clear cache
        }
    }

    @OptIn(FlowPreview::class)
    private suspend fun parseSource(source: File): List<String> {
        return source.walkTopDown()
            .asFlow()
            .filter { file -> file.isSmali }
            .flatMapConcat { file -> parseAPI(smali = file) }
            .toList()
            .distinct()
    }

    private suspend fun parseAPI(smali: File): Flow<String> = withContext(context = Dispatchers.IO) {
        val contents = smali.bufferedReader().use { reader -> reader.readLines() }

        return@withContext contents
            .asFlow()
            .filter { line -> line.isCommand }
            .map { line -> line.asMethod() }
            .filterNot { method -> method.isInitialize } // Ignore init method
            .map { method -> "${method.packageName}.${method.className}.${method.name}" }
            .flowOn(context = Dispatchers.Default)
    }

    companion object {
        private const val ENTRY_META_INF = "META-INF/MANIFEST.MF"
    }
}
