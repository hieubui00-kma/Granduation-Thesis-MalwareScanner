package com.kma.apktool

import com.kma.apktool.data.model.ApkMetadata
import com.kma.apktool.data.model.isInitialize
import com.kma.apktool.util.asMethod
import com.kma.apktool.util.disassemble
import com.kma.apktool.util.isCommand
import com.kma.apktool.util.isSmali
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.FlowPreview
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.filterNot
import kotlinx.coroutines.flow.flatMapConcat
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.withContext
import net.dongliu.apk.parser.exception.ParserException
import net.dongliu.apk.parser.parser.BinaryXmlParser
import net.dongliu.apk.parser.parser.CompositeXmlStreamer
import net.dongliu.apk.parser.parser.ResourceTableParser
import net.dongliu.apk.parser.struct.AndroidConstants
import net.dongliu.apk.parser.struct.resource.ResourceTable
import timber.log.Timber
import java.io.Closeable
import java.io.File
import java.nio.ByteBuffer
import java.nio.channels.FileChannel
import java.util.Locale
import java.util.zip.ZipFile

class ApkFile(path: String) : Closeable {
    private val zipFile: ZipFile by lazy { ZipFile(file) }

    private val fileChannel: FileChannel by lazy { file.inputStream().channel }

    private val file: File

    private lateinit var metadata: ApkMetadata

    val path: String
        get() = file.path

    val size: Long
        get() = file.length()

    init {
        this.file = File(path)
    }

    suspend fun getMetadata(): ApkMetadata = withContext(context = Dispatchers.Default) {
        if (this@ApkFile::metadata.isInitialized) {
            return@withContext metadata
        }

        val resourceTable = async { getResourceTable() }
        val data = getFileData(AndroidConstants.MANIFEST_FILE)
            ?: throw ParserException("AndroidManifest file not found.")
        val buffer = ByteBuffer.wrap(data)
        val parser = BinaryXmlParser(buffer, resourceTable.await())

        metadata = with(receiver = parser) {
            val metadataTranslator = MetadataTranslator()
            val translator = MetadataTranslator()

            this.locale = Locale.US
            this.xmlStreamer = CompositeXmlStreamer(translator, metadataTranslator)
            this.parse()
            return@with translator.metadata
        }
        return@withContext metadata
    }

    private suspend fun getResourceTable() = withContext(context = Dispatchers.Default) {
        val data = getFileData(AndroidConstants.RESOURCE_FILE) ?: return@withContext ResourceTable()
        val buffer = ByteBuffer.wrap(data)
        val resourceTableParser = ResourceTableParser(buffer)

        resourceTableParser.parse()
        return@withContext resourceTableParser.resourceTable
    }

    private suspend fun getFileData(path: String?): ByteArray? = withContext(context = Dispatchers.IO) {
        val entry = zipFile.getEntry(path) ?: return@withContext null

        return@withContext zipFile
            .getInputStream(entry)
            .use { inputStream -> inputStream.readBytes() }
    }

    override fun close() {
        fileChannel.close()
        zipFile.close()
    }

    suspend fun getAPIs(cache: File): List<String> = withContext(context = Dispatchers.Default) {
        val outDir = File(cache, file.nameWithoutExtension)

        try {
            Timber.d(message = "Disassemble...")
            outDir.deleteRecursively()
            outDir.mkdirs()
            file.disassemble(outDir = outDir)

            Timber.d(message = "Parsing...")
            val sources = outDir.listFiles() ?: return@withContext emptyList()

            return@withContext sources.asFlow()
                .map { source -> async { parseSource(source = source) } }
                .toList()
                .awaitAll()
                .flatten()
                .distinct()
        } finally {
            Timber.d(message = "Clear cache...")
            outDir.deleteRecursively() // Clear cache
        }
    }

    @OptIn(FlowPreview::class)
    private suspend fun parseSource(source: File): List<String> {
        return source.walkTopDown()
            .asFlow()
            .filter { file -> file.isSmali }
            .flatMapConcat { file -> parseAPI(smali = file) }
            .toList()
            .distinct()
    }

    private suspend fun parseAPI(smali: File): Flow<String> = withContext(context = Dispatchers.IO) {
        val contents = smali.bufferedReader().use { reader -> reader.readLines() }

        return@withContext contents
            .asFlow()
            .filter { line -> line.isCommand }
            .map { line -> line.asMethod() }
            .filterNot { method -> method.isInitialize } // Ignore init method
            .map { method -> "${method.packageName}.${method.className}.${method.name}" }
            .flowOn(context = Dispatchers.Default)
    }
}
