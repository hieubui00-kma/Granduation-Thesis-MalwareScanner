package com.kma.apktool

import com.kma.apktool.data.model.isInitialize
import com.kma.apktool.util.asMethod
import com.kma.apktool.util.contentStream
import com.kma.apktool.util.disassemble
import com.kma.apktool.util.isCommand
import com.kma.apktool.util.isSmali
import net.dongliu.apk.parser.AbstractApkFile
import net.dongliu.apk.parser.bean.ApkSignStatus
import java.io.File
import java.nio.ByteBuffer
import java.nio.channels.FileChannel
import java.util.zip.ZipFile
import kotlinx.coroutines.FlowPreview
import kotlinx.coroutines.flow.asFlow
import kotlinx.coroutines.flow.filter
import kotlinx.coroutines.flow.filterNot
import kotlinx.coroutines.flow.flatMapConcat
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.toList

class ApkFile : AbstractApkFile {
    private val zipFile: ZipFile by lazy { ZipFile(file) }

    private val fileChannel: FileChannel by lazy { file.inputStream().channel }

    private val file: File

    val path: String
        get() = file.path

    constructor(path: String) : super() {
        this.file = File(path)
    }

    constructor(file: File) : super() {
        this.file = file
    }

    override fun getAllCertificateData(): List<CertificateFile> {
        val certificateFiles = mutableListOf<CertificateFile>()
        val certificatePatterns = arrayOf(".RSA", ".DSA")
        val entries = zipFile.entries()

        while (entries.hasMoreElements()) {
            val entry = entries.nextElement()
                .takeUnless { entry -> entry.isDirectory }
                ?: continue
            val name = entry.name.uppercase()
            val isCertificate = certificatePatterns.any { pattern -> name.endsWith(suffix = pattern) }

            if (isCertificate) {
                val byteArray = zipFile
                    .getInputStream(entry)
                    .use { inputStream -> inputStream.readBytes() }

                certificateFiles += CertificateFile(name, byteArray)
            }
        }
        return certificateFiles
    }

    override fun getFileData(path: String?): ByteArray? {
        val entry = zipFile.getEntry(path) ?: return null

        return zipFile
            .getInputStream(entry)
            .use { inputStream -> inputStream.readBytes() }
    }

    override fun fileData(): ByteBuffer {
        return fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size())
    }

    @Deprecated(message = "Using google official ApkVerifier of apksig lib instead.")
    override fun verifyApk(): ApkSignStatus {
        return when {
            zipFile.getEntry(ENTRY_META_INF) == null -> ApkSignStatus.notSigned
            else -> ApkSignStatus.signed
        }
    }

    override fun close() {
        super.close()
        fileChannel.close()
        zipFile.close()
    }

    @OptIn(FlowPreview::class)
    suspend fun getAPIs(cache: File): List<String> {
        val outDir = disassemble(apk = file, storage = cache)
        val result = outDir.walkTopDown() // Get all file in the folder
            .asFlow()
            .filter { file -> file.isSmali }
            .flatMapConcat { file -> file.contentStream } // Emit all the content of file as lines
            .filter { line -> line.isCommand }
            .map { line -> line.asMethod() }
            .filterNot { method -> method.isInitialize } // Ignore init method
            .map { method -> "${method.packageName}.${method.className}.${method.name}" }
            .toList()

        outDir.deleteRecursively() // Clear cache
        return result
    }

    private suspend fun disassemble(apk: File, storage: File): File {
        val outDir = File(storage, apk.nameWithoutExtension)

        outDir.deleteRecursively()
        outDir.mkdirs()
        apk.disassemble(outDir = outDir)
        return outDir
    }

    companion object {
        private const val ENTRY_META_INF = "META-INF/MANIFEST.MF"
    }
}
